<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>alleleconsolidator &mdash; Allele Expression Consolidator 1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Allele Expression Consolidator
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">alleleconsolidator</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Allele Expression Consolidator</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">alleleconsolidator</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for alleleconsolidator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Algorithmic description</span>
<span class="sd">-----------------------</span>

<span class="sd">The procedure is explained in detail on the following paper, whose datasets can</span>
<span class="sd">be found in the corresponding repository:</span>

<span class="sd">LÃ³pez-Rozo, N.; Ramirez-Castrillon, M.; Romero, M.; Finke, J.; Rocha, C.</span>
<span class="sd">*Gene Expression Datasets for Two Versions of the Saccharum spontaneum AP85-441 Genome*.</span>
<span class="sd">Data 2023, 8, 1. https://doi.org/10.3390/data8010001</span>

<span class="sd">Based on the output of BLASTN, the associations among the alleles in v2018 and</span>
<span class="sd">v2019 are found to have repetitions. In the case of the mappings between v2018</span>
<span class="sd">to v2019, a CDS in the source could be associated with several CDS in the</span>
<span class="sd">target. To generate a reasonable coverage, both mappings are combined by</span>
<span class="sd">modeling the problem as a graph flow optimization problem [20] with multiple</span>
<span class="sd">sources (v2018 alleles) and multiple targets (v2019 alleles).</span>

<span class="sd">A min-cost max-flow problem requires to compute a graph-matching (i.e., match</span>
<span class="sd">at the level of nodes/vertices) with maximal cardinality (i.e., maximal number</span>
<span class="sd">of connections), thus ensuring a maximal covering of the source-target</span>
<span class="sd">associations. If more than one maximal matching is possible, then the cost of</span>
<span class="sd">producing that maximal flow is to be minimized. In this case, identity scores</span>
<span class="sd">can be considered to identify the matching with the greatest sum of identity</span>
<span class="sd">scores, while still ensuring that a v2018 allele expression is used at most</span>
<span class="sd">once. Since the algorithm implemented in networkx minimizes cost, the</span>
<span class="sd">artificial cost fed to the min-cost max-flow algorithm is *pident* (i.e.,</span>
<span class="sd">percent identity) on each possible association between the two versions of the</span>
<span class="sd">alleles.</span>

<span class="sd">|</span>

<span class="sd">**API Reference**</span>
<span class="sd">-----------------</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pickle</span> <span class="k">as</span> <span class="nn">pk</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<div class="viewcode-block" id="read_expression"><a class="viewcode-back" href="../alleleconsolidator.html#alleleconsolidator.read_expression">[docs]</a><span class="k">def</span> <span class="nf">read_expression</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function reads the expression file and returns a list of names and a</span>
<span class="sd">    matrix of expression values.</span>

<span class="sd">    :param file: The path to the expression file.</span>
<span class="sd">    :type file: str</span>
<span class="sd">    :param sep: The separator used in the file.</span>
<span class="sd">    :type sep: str</span>

<span class="sd">    :return names: The list of names.</span>
<span class="sd">    :rtype names: list</span>
<span class="sd">    :return mat: The matrix of expression values.</span>
<span class="sd">    :rtype mat: list[numpy.array]</span>
<span class="sd">    :return headers: The headers of the table (&quot;gene&quot;/&quot;allele&quot; + accession names).</span>
<span class="sd">    :rtype headers: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tmp</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">names</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">headers</span></div>


<div class="viewcode-block" id="create_bipartite_graph"><a class="viewcode-back" href="../alleleconsolidator.html#alleleconsolidator.create_bipartite_graph">[docs]</a><span class="k">def</span> <span class="nf">create_bipartite_graph</span><span class="p">(</span><span class="n">df_map</span><span class="p">,</span> <span class="n">query_col</span><span class="o">=</span><span class="s1">&#39;qseqid&#39;</span><span class="p">,</span> <span class="n">subject_col</span><span class="o">=</span><span class="s1">&#39;sseqid&#39;</span><span class="p">,</span>
                           <span class="n">weight_col</span><span class="o">=</span><span class="s1">&#39;pident&#39;</span><span class="p">,</span> <span class="n">base_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a bipartite graph from the mapping dataframe, which was</span>
<span class="sd">    extracted from the BLASTN output. **Note**: The weight of the edges is</span>
<span class="sd">    multiplied by -1000 and truncated to be used as a cost in the min-cost</span>
<span class="sd">    max-flow algorithm.</span>

<span class="sd">    :param df_map: The mapping dataframe.</span>
<span class="sd">    :type df_map: pandas.DataFrame</span>
<span class="sd">    :param query_col: The name of the column containing the query sequences.</span>
<span class="sd">    :type query_col: str</span>
<span class="sd">    :param subject_col: The name of the column containing the subject sequences.</span>
<span class="sd">    :type subject_col: str</span>
<span class="sd">    :param weight_col: The name of the column containing the weight of the edges.</span>
<span class="sd">    :type weight_col: str</span>
<span class="sd">    :param base_graph: The base graph to be used. if set to None (default), a new \</span>
<span class="sd">    graph is created.</span>
<span class="sd">    :type base_graph: networkx.Graph</span>

<span class="sd">    :return bipartite: The bipartite graph.</span>
<span class="sd">    :rtype bipartite: networkx.Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">base_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bipartite</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bipartite</span> <span class="o">=</span> <span class="n">base_graph</span>
    <span class="n">bipartite</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">df_map</span><span class="p">[</span><span class="n">query_col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">subset</span><span class="o">=</span><span class="n">query_col</span><span class="p">)</span>
    <span class="n">bipartite</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">df_map</span><span class="p">[</span><span class="n">subject_col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">subset</span><span class="o">=</span><span class="n">subject_col</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_map</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bipartite</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">query_col</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="n">subject_col</span><span class="p">]):</span>
            <span class="n">bipartite</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">query_col</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="n">subject_col</span><span class="p">],</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">weight</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1000</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">bipartite</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">query_col</span><span class="p">]][</span><span class="n">row</span><span class="p">[</span><span class="n">subject_col</span><span class="p">]][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1000</span><span class="p">):</span>
            <span class="n">bipartite</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">query_col</span><span class="p">]][</span><span class="n">row</span><span class="p">[</span><span class="n">subject_col</span><span class="p">]][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">weight_col</span><span class="p">]</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1000</span><span class="p">)</span>
            <span class="c1"># print(bipartite[row[query_col]][row[subject_col]])</span>
    <span class="k">return</span> <span class="n">bipartite</span></div>


<div class="viewcode-block" id="draw_multigraph"><a class="viewcode-back" href="../alleleconsolidator.html#alleleconsolidator.draw_multigraph">[docs]</a><span class="k">def</span> <span class="nf">draw_multigraph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">subset_feat</span><span class="p">,</span> <span class="n">x_offset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_offset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">subset_color</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="s2">&quot;purple&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;orange&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">),</span>
                    <span class="n">savefig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;graph.pdf&quot;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function draws a multipartite graph. **Note**: The graph is drawn in</span>
<span class="sd">    the order of the subsets in the list of subset features. The nodes are</span>

<span class="sd">    :param graph: The graph to be drawn.</span>
<span class="sd">    :type graph: networkx.Graph</span>
<span class="sd">    :param subset_feat: The subset feature names. The order of the names is the order \</span>
<span class="sd">    the subsets will be drawn.</span>
<span class="sd">    :param x_offset: The x offset for the subsets and the drawn nodes.</span>
<span class="sd">    :type x_offset: int</span>
<span class="sd">    :param y_offset: The y offset for the subsets and the drawn nodes.</span>
<span class="sd">    :type y_offset: int</span>
<span class="sd">    :param subset_color: The colors of the subsets.</span>
<span class="sd">    :type subset_color: list[str]</span>
<span class="sd">    :param savefig: Whether to save the figure or not.</span>
<span class="sd">    :type savefig: bool</span>
<span class="sd">    :param filename: The name of the file to save the figure.</span>
<span class="sd">    :type filename: str</span>
<span class="sd">    :param node_size: The size of the nodes.</span>
<span class="sd">    :type node_size: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract the nodes of the graph, according to the subsets</span>
    <span class="n">subset_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">subset_sizes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset_color</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">6</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subset_feat</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subset_feat</span><span class="p">:</span>
        <span class="n">subset_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">subset</span><span class="p">])</span>
        <span class="n">subset_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;subset&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">subset</span><span class="p">]))</span>

    <span class="c1"># compute the node positions, according to the subsets. Each layer will be drawn</span>
    <span class="c1"># in a different x coordinate, and the nodes will be centered according to the x-axis.</span>
    <span class="n">node_positions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subset_sizes</span><span class="p">):</span>
        <span class="n">node_positions</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">i</span> <span class="o">*</span> <span class="n">x_offset</span><span class="p">,</span> <span class="n">y_offset</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)])</span>

    <span class="c1"># compute the accumulated sum of the subset sizes</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">subset_sizes</span><span class="p">))</span>

    <span class="c1"># gather a map from the nodes to their positions in the node_positions list</span>
    <span class="n">node_pos_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subset_nodes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>
            <span class="n">node_pos_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span>

    <span class="c1"># draw the nodes using matplotlib.pyplot</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subset_nodes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">node_positions</span><span class="p">[</span><span class="n">ct</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ct</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># draw the edges using matplotlib.pyplot, locating them behind the nodes</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">pos_u</span> <span class="o">=</span> <span class="n">node_positions</span><span class="p">[</span><span class="n">node_pos_map</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span>
        <span class="n">pos_v</span> <span class="o">=</span> <span class="n">node_positions</span><span class="p">[</span><span class="n">node_pos_map</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pos_u</span><span class="p">,</span> <span class="n">pos_v</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="allele_transform"><a class="viewcode-back" href="../alleleconsolidator.html#alleleconsolidator.allele_transform">[docs]</a><span class="k">def</span> <span class="nf">allele_transform</span><span class="p">(</span><span class="n">mapping_1</span><span class="p">,</span> <span class="n">mapping_2</span><span class="p">,</span> <span class="n">expression_1</span><span class="p">,</span> <span class="n">result_folder</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span>
                     <span class="n">expression_2</span><span class="o">=</span><span class="s2">&quot;expression2.csv&quot;</span><span class="p">,</span> <span class="n">prefix_restricted</span><span class="o">=</span><span class="s2">&quot;restricted&quot;</span><span class="p">,</span>
                     <span class="n">blastn_titles</span><span class="o">=</span><span class="s2">&quot;qseqid,sseqid,pident,length,mismatch,gapopen,qstart,&quot;</span>
                                   <span class="s2">&quot;qend,sstart,send,evalue,bitscore&quot;</span><span class="p">,</span>
                     <span class="n">right_subset</span><span class="o">=</span><span class="s2">&quot;qseqid&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function transforms the expression values of the alleles in v2018 to</span>
<span class="sd">    the alleles in v2019. The transformation is done by solving a min-cost</span>
<span class="sd">    max-flow problem with multiple sources (v2018 alleles) and multiple targets</span>
<span class="sd">    (v2019 alleles).</span>

<span class="sd">    Keep in mind that the function stores additional files in the result folder:</span>

<span class="sd">    - *expression_2*: The mapped expression file for v2019, as CSV format.</span>

<span class="sd">    - *prefix_restricted.pk*: The gene assignment, as a dictionary.</span>

<span class="sd">    - *prefix_restricted.txt*: The gene assignment, as a table.</span>

<span class="sd">    :param mapping_1: The path to the mapping file from v2018 to v2019.</span>
<span class="sd">    :type mapping_1: str</span>
<span class="sd">    :param mapping_2: The path to the mapping file from v2019 to v2018.</span>
<span class="sd">    :type mapping_2: str</span>
<span class="sd">    :param expression_1: The path to the expression file of v2018.</span>
<span class="sd">    :type expression_1: str</span>
<span class="sd">    :param result_folder: The path to the folder where the results will be saved.</span>
<span class="sd">    :type result_folder: str</span>
<span class="sd">    :param expression_2: The name of the expression file of v2019.</span>
<span class="sd">    :type expression_2: str</span>
<span class="sd">    :param prefix_restricted: The prefix of the restricted alleles.</span>
<span class="sd">    :type prefix_restricted: str</span>
<span class="sd">    :param blastn_titles: The titles of the BLASTN output.</span>
<span class="sd">    :type blastn_titles: str</span>
<span class="sd">    :param right_subset: The subset identifier of the left nodes of the bipartite graph.</span>
<span class="sd">    :type right_subset: str</span>
<span class="sd">    :param verbose: If set to True, the function prints the time at the beginning \</span>
<span class="sd">    and the end of the execution.</span>
<span class="sd">    :type verbose: bool</span>

<span class="sd">    :return bipartite: The bipartite graph used for computing the min-cost max-flow.</span>
<span class="sd">    :rtype bipartite: networkx.Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%a</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> %b %Y %H:%M:%S&quot;</span><span class="p">))</span>
    <span class="n">names</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">read_expression</span><span class="p">(</span><span class="n">expression_1</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">titles</span> <span class="o">=</span> <span class="n">blastn_titles</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">df_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">mapping_1</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="n">titles</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">)</span>
    <span class="c1"># take duplicated queries</span>
    <span class="c1"># df_dup = df_map[df_map.duplicated(&#39;sseqid&#39;)]</span>
    <span class="c1"># rep_CDS = df_dup[&#39;sseqid&#39;].unique()</span>
    <span class="c1"># tmp = df_map[df_map[&#39;sseqid&#39;].isin(rep_CDS)].sort_values(by=[&#39;sseqid&#39;])</span>
    <span class="c1"># if verbose:</span>
    <span class="c1">#     print(tmp)</span>

    <span class="c1"># Bipartite graph creation: Phase 1</span>
    <span class="n">bipartite</span> <span class="o">=</span> <span class="n">create_bipartite_graph</span><span class="p">(</span><span class="n">df_map</span><span class="p">,</span> <span class="n">query_col</span><span class="o">=</span><span class="s1">&#39;qseqid&#39;</span><span class="p">,</span> <span class="n">subject_col</span><span class="o">=</span><span class="s1">&#39;sseqid&#39;</span><span class="p">,</span>
                                       <span class="n">weight_col</span><span class="o">=</span><span class="s1">&#39;pident&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase 1: (V,E) = (</span><span class="si">{</span><span class="n">bipartite</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">bipartite</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="c1"># now load the opposite direction, but change the first two column names</span>
    <span class="c1"># [&quot;sseqid&quot;, &quot;qseqid&quot;, &quot;pident&quot;, ...]</span>
    <span class="n">df_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">mapping_2</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">)</span>

    <span class="c1"># Note: edge direction is opposite to the previous function call</span>
    <span class="n">bipartite</span> <span class="o">=</span> <span class="n">create_bipartite_graph</span><span class="p">(</span><span class="n">df_map</span><span class="p">,</span> <span class="n">query_col</span><span class="o">=</span><span class="s1">&#39;qseqid&#39;</span><span class="p">,</span> <span class="n">subject_col</span><span class="o">=</span><span class="s1">&#39;sseqid&#39;</span><span class="p">,</span>
                                       <span class="n">weight_col</span><span class="o">=</span><span class="s1">&#39;pident&#39;</span><span class="p">,</span> <span class="n">base_graph</span><span class="o">=</span><span class="n">bipartite</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Phase 2: (V,E) = (</span><span class="si">{</span><span class="n">bipartite</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">bipartite</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="c1"># &quot;qseqid&quot;, &quot;sseqid&quot;, &quot;pident&quot;, ...</span>
    <span class="n">df_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">mapping_1</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">titles</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">)</span>
    <span class="c1"># MAXIMUM MATCHING OF EACH COMPONENT OF BIPARTITE</span>
    <span class="c1"># (computed only when the number of nodes to the right is &gt;1)</span>
    <span class="n">restricted</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># dictionary of restricted edges (used in the max flow)</span>
    <span class="n">l_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">bipartite</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;subset&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">r_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bipartite</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="n">l_nodes</span>

    <span class="c1"># Configuring source and target for graph flow problem</span>
    <span class="n">bipartite</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;SS&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="s1">&#39;SS&#39;</span><span class="p">)</span>
    <span class="n">bipartite</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;ST&#39;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="s1">&#39;ST&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">l_nodes</span><span class="p">:</span>
        <span class="n">bipartite</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;SS&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weigth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># zero weight</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">r_nodes</span><span class="p">:</span>
        <span class="n">bipartite</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;ST&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># infinite capacity, zero weight</span>
    <span class="n">maxflow</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">max_flow_min_cost</span><span class="p">(</span><span class="n">bipartite</span><span class="p">,</span> <span class="s1">&#39;SS&#39;</span><span class="p">,</span> <span class="s1">&#39;ST&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%a</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> %b %Y %H:%M:%S&quot;</span><span class="p">),</span> <span class="s2">&quot;Sum of PIDENT values:&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.001</span><span class="o">*</span><span class="n">nx</span><span class="o">.</span><span class="n">cost_of_flow</span><span class="p">(</span><span class="n">bipartite</span><span class="p">,</span> <span class="n">maxflow</span><span class="p">))</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bipartite</span><span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">]):</span>
        <span class="n">ct</span><span class="p">[</span><span class="n">maxflow</span><span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">][</span><span class="n">v</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Flow [0, 1, -1] =&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># counter of the number of assigned genes</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bipartite</span><span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">]):</span>
        <span class="c1"># if maxflow[&#39;SS&#39;][v][&#39;flow&#39;] == 1:</span>
        <span class="k">if</span> <span class="n">maxflow</span><span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">ct</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">maxflow</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="s1">&#39;SS&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># if maxflow[v][u][&#39;flow&#39;] == 1:</span>
            <span class="k">if</span> <span class="n">maxflow</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">maxflow</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Flow from v to u goes from left to right only</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">restricted</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> appears assigned twice! </span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">restricted</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bipartite</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">maxflow</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="si">}</span><span class="se">\t</span><span class="s2"> </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">maxflow</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">bipartite</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">l_nodes</span><span class="p">:</span>
                                    <span class="k">continue</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">maxflow</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="si">}</span><span class="se">\t</span><span class="s2"> </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">maxflow</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> appears assigned twice! </span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">restricted</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">restricted</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
    <span class="c1"># extracting the names of the genes as all nodes adjacent to the &#39;ST&#39; node</span>
    <span class="n">new_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bipartite</span><span class="p">[</span><span class="s1">&#39;ST&#39;</span><span class="p">]]</span>
    <span class="n">dict_old</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">u</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)}</span>
    <span class="n">dict_new</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">u</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_names</span><span class="p">)}</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">new_names</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">exp</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="c1"># print(dict_old)</span>
    <span class="c1"># print(dict_new)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of resulting transcripts:&quot;</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of genes:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_names</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restricted</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">restricted</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># print(key, value)</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">dict_new</span><span class="p">[</span><span class="n">value</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">[</span><span class="n">dict_old</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

    <span class="c1"># Saving the resulting DataFrame</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">result_folder</span> <span class="o">+</span> <span class="n">expression_2</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_names</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">pk</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">restricted</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">result_folder</span><span class="si">}{</span><span class="n">prefix_restricted</span><span class="si">}</span><span class="s2">.pk&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">result_folder</span><span class="si">}{</span><span class="n">prefix_restricted</span><span class="si">}</span><span class="s2">.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;key,value</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restricted</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">restricted</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%a</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> %b %Y %H:%M:%S&quot;</span><span class="p">),</span> <span class="s2">&quot;DONE!&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bipartite</span></div>


<span class="k">def</span> <span class="nf">_test1</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Testing the allele_transform function using extracted data from the data folder.</span>
<span class="sd">    It plots the resulting graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_mapping_1</span> <span class="o">=</span> <span class="s2">&quot;blast_1.txt&quot;</span>
    <span class="n">file_mapping_2</span> <span class="o">=</span> <span class="s2">&quot;blast_2.txt&quot;</span>
    <span class="n">file_expression_in</span> <span class="o">=</span> <span class="s2">&quot;expression.csv&quot;</span>
    <span class="n">file_expression_out</span> <span class="o">=</span> <span class="s2">&quot;expression_2.csv&quot;</span>
    <span class="n">folder_in</span> <span class="o">=</span> <span class="s2">&quot;data/&quot;</span>
    <span class="n">folder_out</span> <span class="o">=</span> <span class="s2">&quot;test_results/&quot;</span>
    <span class="n">prefix_restricted</span> <span class="o">=</span> <span class="s2">&quot;restricted&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">allele_transform</span><span class="p">(</span><span class="n">folder_in</span> <span class="o">+</span> <span class="n">file_mapping_1</span><span class="p">,</span> <span class="n">folder_in</span> <span class="o">+</span> <span class="n">file_mapping_2</span><span class="p">,</span>
                         <span class="n">folder_in</span> <span class="o">+</span> <span class="n">file_expression_in</span><span class="p">,</span> <span class="n">folder_out</span><span class="p">,</span>
                         <span class="n">file_expression_out</span><span class="p">,</span> <span class="n">prefix_restricted</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Results from the allele transform algorithm (first 10 lines):&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">folder_out</span><span class="si">}{</span><span class="n">prefix_restricted</span><span class="si">}</span><span class="s2">.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[:</span><span class="mi">10</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

    <span class="c1"># Plotting the resulting graph</span>
    <span class="n">draw_multigraph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;SS&quot;</span><span class="p">,</span> <span class="s2">&quot;qseqid&quot;</span><span class="p">,</span> <span class="s2">&quot;sseqid&quot;</span><span class="p">,</span> <span class="s2">&quot;ST&quot;</span><span class="p">],</span> <span class="n">x_offset</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">savefig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;test_results/graph.pdf&quot;</span><span class="p">)</span>

    <span class="c1"># pos = nx.spring_layout(g, seed=42)  # Define the layout of the graph</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">bipartite_layout</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">])</span>  <span class="c1"># Define the layout of the graph</span>
    <span class="n">pos</span><span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">pos</span><span class="p">[</span><span class="s1">&#39;ST&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s2">&quot;capacity&quot;</span><span class="p">)</span>  <span class="c1"># Get the edge capacities as labels</span>

    <span class="c1"># Draw nodes and edges</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;lightblue&quot;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
    <span class="c1"># nx.draw_networkx_labels(g, pos)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>

    <span class="c1"># Display the graph</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">_test1</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, NicolÃ¡s LÃ³pez, Jorge Finke, and Camilo Rocha.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>